---
title: "R Strings"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
library(tidyverse)
library(datos)
```

#Stringr

## Para poder utilizar caracteres especiales en un texto.

```{r caracteres_especiales}

comilla_doble <- "\""  # o '"'
comilla_simple <- '\'' # o "'"
x <- c("\"", "\\")

# para verificar, utilizar writeLines()

writeLines(x)

x <- "\u00b5"
x
```

Backslash se usa para empezar una secuencia de escape en una constante de caracteres. Sólo sirve para los strings de la siguiente tabla, si se usa en otros da error.  

Single quotes hace escape con backslash en una cadena con single-quoted, and double quotes in double-quoted cadena.

\n	newline
\r	carriage return
\t	tab
\b	backspace
\a	alert (bell)
\f	form feed
\v	vertical tab
\\	backslash \
\'	ASCII apostrophe '
\"	ASCII quotation mark "
\`	ASCII grave accent (backtick) `
\nnn	character with given octal code (1, 2 or 3 digits)
\xnn	character with given hex code (1 or 2 hex digits)
\unnnn	Unicode character with given code (1--4 hex digits)
\Unnnnnnnn	Unicode character with given code (1--8 hex digits)
Alternative forms for the last two are \u{nnnn} and \U{nnnnnnnn}. All except the Unicode escape sequences are also supported when reading character strings by scan and read.table if allowEscapes = TRUE. Unicode escapes can be used to enter Unicode characters not in the current locale's charset (when the string will be stored internally in UTF-8).

## Funciones de cadena

```{r str_length}

str_length((c("a", "R para Ciencia de Datos", NA)))
```

* str_c() es una función vectorizada que automáticamente recicla los vectores más cortos hasta alcanzar la extensión del más largo. Los objetos de extensión 0 se descartan de manera silenciosa. Esto es particularmente útil en conjunto con if (si)

```{r str_c y str_replace_na}
str_c("x", "y", "z")
x <- c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
str_c(c("x", "y", "z"), collapse = ", ") #Para colapsar un vector de cadenas en una sola


nombre <- "Hadley"
hora_del_dia <- "mañana"
cumpleanios <- FALSE

str_c(
  "Que tengas una buena ", hora_del_dia, ", ", nombre,
  if (cumpleanios) " y ¡FELIZ CUMPLEAÑOS!",
  "."   # Si cumpleaños = FALSE es una cadena de long. 0... no se colapsa
)
```
```{r str_sub y str_to_lower}
y <- c("Manzana", "Plátano", "Pera")
str_sub(y, 1, 3)
str_sub(y, -3, -1)

str_sub("a", 1, 5) #str_sub() no fallará si la cadena
str_sub(y, 1, 1) <- str_to_lower(str_sub(y, 1, 1)) #usado para modificar un string
```


## Locale
Las reglas no son iguales en todos los idiomas, algunas veces hacer falta el uso de locale. Por ejemplo el turco tiene dos i distintas.
Otra operación importante que es afectada por el locale es ordenar

```{r locale str_to_upper y str_to_title y str_sort}
str_to_upper(c("i", "ı"))
str_to_upper(c("i", "ı"), locale = "tr")
x <- c("arándano", "espinaca", "banana")
str_sort(x, locale = "es")  # Español
str_sort(x, locale = "haw") # Hawaiano
```

## Expresiones regulares y coincidencias  

Coincidencias  
Anclas :
* ^ para buscar la coincidencia al inicio de la cadena.
* $ para buscar la coincidencia al final de la cadena.

```{r str_view y str_view_all}

x <- c("manzana", "banana", "pera")
str_view(x, "an")   # coincidencia simple

str_view(x, ".a.") # indica cualquier caracter (excepto salto de linea) antes y después de a
str_view(c("abc", "a.c", "bef"), "a\\.c") # si se quiere buscar de forma explícita el . se necesitan \\ (expressión regular)

# Para crear una expresión regular necesitamos \\
punto <- "\\."


x <- "a\\b"
writeLines(x)


str_view(x, "\\\\")


x <- c("arandano", "banana", "pera")
str_view(x,  "^a" )
str_view(x, "a$")

x <- c("pie de manzana", "manzana", "queque de manzana")
str_view(x, "manzana")
str_view(x, "^manzana$") #para buscar exactamente sin nada más delante ni detrás.

```

## Clases de caracteres y alternativas:

* .         coincide con cualquier caracter (execpto salto de línea)    (para exp.reg \.)
* \d        coincide con cualquier dígito                               (para exp.reg  \\d)
* \s: coincide con cualquier espacio en blanco (por ejemplo, espacio simple, 
      tabulador, salto de línea).                                       (para exp.reg  \\s)
* [abc]     coincide con a b o c. 
* [^abc]    coincide con todos menos a b o c.

```{r exp_reg[]}
# Buscar de forma literal un caracter que usualmente tiene un significado especial en una expresión regular
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
str_view(c("abc", "a.c", "a*c", "a c"), "a[ ]")
```
**funciona con los siguientes metacaracteres de las expresiones regulares: $ . | ? * + ( ) [ { **  
**estos otros deben manejarse con \ para escaparlos: ] \ ^ y - **


##Disyunción
Sirve para elegir entre uno más patrones alternativos. Por ej. abc|d..a coincide tanto con "abc" como con "duna".

```{r disyunción_|}
str_view(c("cómo", "como"), "c(ó|o)mo")
str_view(c("abc", "abcyz", "abxyz", "xyz"), "abc|xyz")
```


##Ejercicios
1.Crea una expresión regular que encuentre todas las palabras que:

```{r}
#1 Empiecen con una vocal.
x <- c("anana", "Espacial", "inutil", "omaggio", "Ursula", "bANANA")
str_view(x, "^[aAeEiIoOuU]")

#2 Solo contengan consonantes. (Pista: piensa en cómo buscar coincidencias para “no”-vocales.)
str_view(x, "^[^aAeEiIoOuU]")

#3 Terminen en ón, pero no en ión
x <- c("partenon", "canción")
str_view(x, "ón" )
```

